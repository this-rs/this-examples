use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};
use endpoint_benchmarks::{
    create_graphql_server_dynamodb, create_rest_server_dynamodb, data, start_test_server,
    TestServer,
};
use serde_json::json;
use std::time::{Duration, Instant};
use tokio::runtime::Runtime;

/// Stress test DynamoDB avec mÃ©triques dÃ©taillÃ©es
async fn dynamodb_stress_test(
    server: &TestServer,
    concurrent_requests: usize,
    endpoint: &str,
    operation: &str,
) -> anyhow::Result<StressTestResults> {
    let start_time = Instant::now();
    let mut latencies = Vec::new();
    let mut errors = 0;
    let mut timeouts = 0;

    println!(
        "\nğŸ”¥ DynamoDB Stress Test: {} requÃªtes sur {}",
        concurrent_requests, endpoint
    );

    let tasks = (0..concurrent_requests).map(|i| {
        let server = server.clone();
        let endpoint = endpoint.to_string();
        let operation = operation.to_string();

        tokio::spawn(async move {
            let start = Instant::now();

            let result = match operation.as_str() {
                "GET" => {
                    server.get(&endpoint).await
                },
                "POST" => {
                let sample_data = match endpoint.as_str() {
                    "/orders" => data::sample_order(),
                    "/invoices" => data::sample_invoice(),
                    "/payments" => data::sample_payment(),
                    _ => data::sample_order(),
                };
                    server.post_json(&endpoint, sample_data).await
                },
                "GRAPHQL_QUERY" => {
                    let query = json!({"query": "query { orders { id name number amount status } }"});
                    server.post_json("/graphql", query).await
                },
                "GRAPHQL_MUTATION" => {
                    let mutation = json!({
                        "query": "mutation CreateOrder($input: OrderInput!) { createOrder(input: $input) { id name } }",
                        "variables": {
                            "input": {
                                "name": format!("Stress Test Order {}", i),
                                "status": "pending",
                                "number": format!("STR-{:05}", i),
                                "amount": 100.0 + (i as f64),
                                "customer_name": "Stress Test Customer",
                                "notes": "Generated by stress test"
                            }
                        }
                    });
                    server.post_json("/graphql", mutation).await
                },
                _ => server.get(&endpoint).await
            };

            let elapsed = start.elapsed();

            match result {
                Ok(response) => {
                    let status = response.status();
                    if status.is_success() {
                        Ok::<(u128, bool, bool), anyhow::Error>((elapsed.as_micros(), false, false))
                    } else {
                        println!("âš ï¸ Erreur HTTP {}: {}", status, endpoint);
                        Ok::<(u128, bool, bool), anyhow::Error>((elapsed.as_micros(), true, false))
                    }
                },
                Err(e) => {
                    let is_timeout = e.to_string().contains("timeout") || e.to_string().contains("timed out");
                    if is_timeout {
                        println!("â° Timeout sur {}: {}", endpoint, e);
                    } else {
                        println!("âŒ Erreur sur {}: {}", endpoint, e);
                    }
                    Ok::<(u128, bool, bool), anyhow::Error>((elapsed.as_micros(), !is_timeout, is_timeout))
                }
            }
        })
    });

    let results = futures::future::join_all(tasks).await;
    let total_time = start_time.elapsed();

    // Collecter les rÃ©sultats
    for result in results {
        match result? {
            Ok((latency, is_error, is_timeout)) => {
                latencies.push(latency);
                if is_error {
                    errors += 1;
                }
                if is_timeout {
                    timeouts += 1;
                }
            }
            Err(_) => errors += 1,
        }
    }

    latencies.sort();
    let len = latencies.len();

    Ok(StressTestResults {
        total_requests: concurrent_requests,
        successful_requests: len - errors - timeouts,
        failed_requests: errors,
        timeout_requests: timeouts,
        total_time,
        latencies,
        requests_per_second: if total_time.as_secs_f64() > 0.0 {
            concurrent_requests as f64 / total_time.as_secs_f64()
        } else {
            0.0
        },
    })
}

#[derive(Debug)]
struct StressTestResults {
    total_requests: usize,
    successful_requests: usize,
    failed_requests: usize,
    timeout_requests: usize,
    total_time: Duration,
    latencies: Vec<u128>,
    requests_per_second: f64,
}

impl StressTestResults {
    fn print_stats(&self, test_name: &str) {
        let len = self.latencies.len();
        if len == 0 {
            println!("âŒ Aucune mesure valide pour {}", test_name);
            return;
        }

        let avg = self.latencies.iter().sum::<u128>() / len as u128;
        let min = *self.latencies.first().unwrap_or(&0);
        let max = *self.latencies.last().unwrap_or(&0);
        let p50 = self.latencies.get(len / 2).copied().unwrap_or(0);
        let p95 = self.latencies.get(len * 95 / 100).copied().unwrap_or(0);
        let p99 = self.latencies.get(len * 99 / 100).copied().unwrap_or(0);

        println!("\nğŸ“Š === {} ===", test_name);
        println!(
            "ğŸ¯ RequÃªtes: {} total, {} rÃ©ussies, {} Ã©checs, {} timeouts",
            self.total_requests,
            self.successful_requests,
            self.failed_requests,
            self.timeout_requests
        );
        println!("â±ï¸  Temps total: {:?}", self.total_time);
        println!("ğŸš€ Throughput: {:.1} req/s", self.requests_per_second);
        println!("ğŸ“ˆ Latences:");
        println!("   Min: {:.1}ms", min as f64 / 1000.0);
        println!("   Avg: {:.1}ms", avg as f64 / 1000.0);
        println!("   P50: {:.1}ms", p50 as f64 / 1000.0);
        println!("   P95: {:.1}ms", p95 as f64 / 1000.0);
        println!("   P99: {:.1}ms", p99 as f64 / 1000.0);
        println!("   Max: {:.1}ms", max as f64 / 1000.0);

        // Analyse des performances
        let success_rate = (self.successful_requests as f64 / self.total_requests as f64) * 100.0;
        println!("âœ… Taux de succÃ¨s: {:.1}%", success_rate);

        if p95 as f64 / 1000.0 < 100.0 {
            println!("ğŸ‰ Performance excellente (P95 < 100ms)");
        } else if p95 as f64 / 1000.0 < 500.0 {
            println!("ğŸ‘ Performance acceptable (P95 < 500ms)");
        } else {
            println!("âš ï¸  Performance dÃ©gradÃ©e (P95 > 500ms)");
        }
    }
}

fn dynamodb_stress_test_scaling(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    // Try to create server with DynamoDB
    let server_result = rt.block_on(async {
        match create_rest_server_dynamodb().await {
            Ok(router) => start_test_server(router).await,
            Err(e) => {
                println!("ğŸš« DynamoDB non disponible pour stress test: {}", e);
                println!("ğŸ’¡ Conseil: Lancez './setup_dynamodb.sh start' d'abord");
                Err(e)
            }
        }
    });

    let server = match server_result {
        Ok(s) => s,
        Err(_) => {
            println!("â­ï¸  Skipping DynamoDB stress tests - DynamoDB non disponible");
            return;
        }
    };

    let mut group = c.benchmark_group("dynamodb_stress_scaling");
    group.measurement_time(Duration::from_secs(30)); // Plus de temps pour les stress tests

    // Test de montÃ©e en charge progressive
    for concurrent_req in [1, 5, 10, 25, 50, 100].iter() {
        group.bench_with_input(
            BenchmarkId::new("rest_get_scaling", concurrent_req),
            concurrent_req,
            |b, &concurrent_req| {
                b.to_async(&rt).iter(|| async {
                    let results = dynamodb_stress_test(&server, concurrent_req, "/orders", "GET")
                        .await
                        .unwrap();
                    results.print_stats(&format!("GET /orders - {} requÃªtes", concurrent_req));
                    black_box(results);
                });
            },
        );
    }

    group.finish();
}

fn dynamodb_stress_test_operations(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    let server_result = rt.block_on(async {
        match create_rest_server_dynamodb().await {
            Ok(router) => start_test_server(router).await,
            Err(e) => {
                println!("ğŸš« DynamoDB non disponible: {}", e);
                Err(e)
            }
        }
    });

    let server = match server_result {
        Ok(s) => s,
        Err(_) => return,
    };

    let mut group = c.benchmark_group("dynamodb_stress_operations");
    group.measurement_time(Duration::from_secs(20));

    // Test diffÃ©rentes opÃ©rations avec charge modÃ©rÃ©e
    let operations = vec![
        ("GET_orders", "/orders", "GET"),
        ("POST_orders", "/orders", "POST"),
        ("GET_invoices", "/invoices", "GET"),
        ("POST_invoices", "/invoices", "POST"),
        ("GET_payments", "/payments", "GET"),
        ("POST_payments", "/payments", "POST"),
    ];

    for (test_name, endpoint, operation) in operations {
        group.bench_with_input(
            BenchmarkId::new("operation", test_name),
            &(endpoint, operation),
            |b, &(endpoint, operation)| {
                b.to_async(&rt).iter(|| async {
                    let results = dynamodb_stress_test(&server, 20, endpoint, operation)
                        .await
                        .unwrap();
                    results.print_stats(&format!("{} {} - 20 requÃªtes", operation, endpoint));
                    black_box(results);
                });
            },
        );
    }

    group.finish();
}

fn dynamodb_stress_test_graphql(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    let server_result = rt.block_on(async {
        match create_graphql_server_dynamodb().await {
            Ok(router) => start_test_server(router).await,
            Err(e) => {
                println!("ğŸš« DynamoDB GraphQL non disponible: {}", e);
                Err(e)
            }
        }
    });

    let server = match server_result {
        Ok(s) => s,
        Err(_) => return,
    };

    let mut group = c.benchmark_group("dynamodb_stress_graphql");
    group.measurement_time(Duration::from_secs(20));

    // Test GraphQL avec DynamoDB
    let graphql_operations = vec![
        ("GraphQL_Query", "/graphql", "GRAPHQL_QUERY"),
        ("GraphQL_Mutation", "/graphql", "GRAPHQL_MUTATION"),
    ];

    for (test_name, endpoint, operation) in graphql_operations {
        group.bench_with_input(
            BenchmarkId::new("graphql", test_name),
            &(endpoint, operation),
            |b, &(endpoint, operation)| {
                b.to_async(&rt).iter(|| async {
                    let results = dynamodb_stress_test(&server, 15, endpoint, operation)
                        .await
                        .unwrap();
                    results.print_stats(&format!("GraphQL {} - 15 requÃªtes", test_name));
                    black_box(results);
                });
            },
        );
    }

    group.finish();
}

fn dynamodb_endurance_test(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    let server_result = rt.block_on(async {
        match create_rest_server_dynamodb().await {
            Ok(router) => start_test_server(router).await,
            Err(e) => {
                println!("ğŸš« DynamoDB non disponible pour endurance test: {}", e);
                Err(e)
            }
        }
    });

    let server = match server_result {
        Ok(s) => s,
        Err(_) => return,
    };

    let mut group = c.benchmark_group("dynamodb_endurance");
    group.measurement_time(Duration::from_secs(60)); // Test d'endurance de 1 minute
    group.sample_size(10); // Moins d'Ã©chantillons pour le test d'endurance

    group.bench_function("sustained_load_dynamodb", |b| {
        b.to_async(&rt).iter(|| async {
            println!("\nğŸƒâ€â™‚ï¸ === Test d'endurance DynamoDB (charge soutenue) ===");

            // Simuler une charge constante pendant la durÃ©e du test
            let mut total_requests = 0;
            let mut all_latencies = Vec::new();
            let test_start = Instant::now();

            // Envoyer des vagues de 10 requÃªtes toutes les 100ms
            while test_start.elapsed() < Duration::from_secs(5) {
                // 5 secondes pour le bench
                let wave_results = dynamodb_stress_test(&server, 10, "/orders", "GET")
                    .await
                    .unwrap();
                total_requests += wave_results.total_requests;
                all_latencies.extend(wave_results.latencies);

                tokio::time::sleep(Duration::from_millis(100)).await;
            }

            let total_time = test_start.elapsed();
            let rps = total_requests as f64 / total_time.as_secs_f64();

            all_latencies.sort();
            let len = all_latencies.len();
            let avg = if len > 0 {
                all_latencies.iter().sum::<u128>() / len as u128
            } else {
                0
            };
            let p95 = if len > 0 {
                all_latencies[len * 95 / 100]
            } else {
                0
            };

            println!("ğŸ† Test d'endurance terminÃ©:");
            println!("   Total requÃªtes: {}", total_requests);
            println!("   DurÃ©e: {:?}", total_time);
            println!("   RPS moyen: {:.1}", rps);
            println!("   Latence moyenne: {:.1}ms", avg as f64 / 1000.0);
            println!("   P95: {:.1}ms", p95 as f64 / 1000.0);

            black_box((total_requests, rps, avg));
        });
    });

    group.finish();
}

criterion_group!(
    benches,
    dynamodb_stress_test_scaling,
    dynamodb_stress_test_operations,
    dynamodb_stress_test_graphql,
    dynamodb_endurance_test
);

criterion_main!(benches);
